/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "../../common";

export interface HPPart3Interface extends Interface {
  getFunction(
    nameOrSignature:
      | "buyLotteryTicket"
      | "buyOption"
      | "closePerpetualPosition"
      | "completeEscrow"
      | "createEscrow"
      | "createLottery"
      | "createPredictionMarket"
      | "depositMargin"
      | "escrowCounter"
      | "escrows"
      | "exerciseOption"
      | "flashLoan"
      | "limitOrderCount"
      | "limitOrders"
      | "listNFT"
      | "lotteries"
      | "lotteryCounter"
      | "marginBalance"
      | "mintNFT"
      | "nftContract"
      | "openPerpetualPosition"
      | "optionCount"
      | "options"
      | "owner"
      | "perpetualCount"
      | "perpetuals"
      | "placeLimitOrder"
      | "placePrediction"
      | "predictionBets"
      | "predictionCounter"
      | "predictionSide"
      | "predictions"
  ): FunctionFragment;

  getEvent(
    nameOrSignatureOrTopic:
      | "EscrowCreated"
      | "FlashLoanExecuted"
      | "LimitOrderPlaced"
      | "LotteryCreated"
      | "LotteryTicketBought"
      | "MarginDeposited"
      | "OptionBought"
      | "PerpetualOpened"
      | "PredictionMarketCreated"
      | "PredictionPlaced"
  ): EventFragment;

  encodeFunctionData(
    functionFragment: "buyLotteryTicket",
    values: [BigNumberish, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "buyOption",
    values: [boolean, BigNumberish, BigNumberish, BigNumberish, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "closePerpetualPosition",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "completeEscrow",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "createEscrow",
    values: [AddressLike, AddressLike, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "createLottery",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "createPredictionMarket",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "depositMargin",
    values: [BigNumberish, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "escrowCounter",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "escrows",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "exerciseOption",
    values: [BigNumberish, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "flashLoan",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "limitOrderCount",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "limitOrders",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "listNFT",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "lotteries",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "lotteryCounter",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "marginBalance",
    values: [AddressLike]
  ): string;
  encodeFunctionData(functionFragment: "mintNFT", values: [string]): string;
  encodeFunctionData(
    functionFragment: "nftContract",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "openPerpetualPosition",
    values: [boolean, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "optionCount",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "options",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "perpetualCount",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "perpetuals",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "placeLimitOrder",
    values: [AddressLike, AddressLike, BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "placePrediction",
    values: [BigNumberish, boolean, BigNumberish, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "predictionBets",
    values: [BigNumberish, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "predictionCounter",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "predictionSide",
    values: [BigNumberish, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "predictions",
    values: [BigNumberish]
  ): string;

  decodeFunctionResult(
    functionFragment: "buyLotteryTicket",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "buyOption", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "closePerpetualPosition",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "completeEscrow",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createEscrow",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createLottery",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createPredictionMarket",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "depositMargin",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "escrowCounter",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "escrows", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "exerciseOption",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "flashLoan", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "limitOrderCount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "limitOrders",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "listNFT", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "lotteries", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "lotteryCounter",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "marginBalance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "mintNFT", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "nftContract",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "openPerpetualPosition",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "optionCount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "options", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "perpetualCount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "perpetuals", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "placeLimitOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "placePrediction",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "predictionBets",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "predictionCounter",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "predictionSide",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "predictions",
    data: BytesLike
  ): Result;
}

export namespace EscrowCreatedEvent {
  export type InputTuple = [
    escrowId: BigNumberish,
    seller: AddressLike,
    buyer: AddressLike
  ];
  export type OutputTuple = [escrowId: bigint, seller: string, buyer: string];
  export interface OutputObject {
    escrowId: bigint;
    seller: string;
    buyer: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FlashLoanExecutedEvent {
  export type InputTuple = [
    user: AddressLike,
    token: AddressLike,
    amount: BigNumberish
  ];
  export type OutputTuple = [user: string, token: string, amount: bigint];
  export interface OutputObject {
    user: string;
    token: string;
    amount: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace LimitOrderPlacedEvent {
  export type InputTuple = [user: AddressLike, orderId: BigNumberish];
  export type OutputTuple = [user: string, orderId: bigint];
  export interface OutputObject {
    user: string;
    orderId: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace LotteryCreatedEvent {
  export type InputTuple = [lotteryId: BigNumberish, ticketPrice: BigNumberish];
  export type OutputTuple = [lotteryId: bigint, ticketPrice: bigint];
  export interface OutputObject {
    lotteryId: bigint;
    ticketPrice: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace LotteryTicketBoughtEvent {
  export type InputTuple = [lotteryId: BigNumberish, buyer: AddressLike];
  export type OutputTuple = [lotteryId: bigint, buyer: string];
  export interface OutputObject {
    lotteryId: bigint;
    buyer: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace MarginDepositedEvent {
  export type InputTuple = [user: AddressLike, amount: BigNumberish];
  export type OutputTuple = [user: string, amount: bigint];
  export interface OutputObject {
    user: string;
    amount: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace OptionBoughtEvent {
  export type InputTuple = [
    user: AddressLike,
    optionId: BigNumberish,
    isCall: boolean,
    strike: BigNumberish
  ];
  export type OutputTuple = [
    user: string,
    optionId: bigint,
    isCall: boolean,
    strike: bigint
  ];
  export interface OutputObject {
    user: string;
    optionId: bigint;
    isCall: boolean;
    strike: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace PerpetualOpenedEvent {
  export type InputTuple = [
    user: AddressLike,
    positionId: BigNumberish,
    isLong: boolean,
    leverage: BigNumberish
  ];
  export type OutputTuple = [
    user: string,
    positionId: bigint,
    isLong: boolean,
    leverage: bigint
  ];
  export interface OutputObject {
    user: string;
    positionId: bigint;
    isLong: boolean;
    leverage: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace PredictionMarketCreatedEvent {
  export type InputTuple = [marketId: BigNumberish, question: string];
  export type OutputTuple = [marketId: bigint, question: string];
  export interface OutputObject {
    marketId: bigint;
    question: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace PredictionPlacedEvent {
  export type InputTuple = [
    marketId: BigNumberish,
    user: AddressLike,
    side: boolean,
    amount: BigNumberish
  ];
  export type OutputTuple = [
    marketId: bigint,
    user: string,
    side: boolean,
    amount: bigint
  ];
  export interface OutputObject {
    marketId: bigint;
    user: string;
    side: boolean;
    amount: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface HPPart3 extends BaseContract {
  connect(runner?: ContractRunner | null): HPPart3;
  waitForDeployment(): Promise<this>;

  interface: HPPart3Interface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  buyLotteryTicket: TypedContractMethod<
    [lotteryId: BigNumberish, token: AddressLike],
    [void],
    "nonpayable"
  >;

  buyOption: TypedContractMethod<
    [
      isCall: boolean,
      strike: BigNumberish,
      premium: BigNumberish,
      expiry: BigNumberish,
      token: AddressLike
    ],
    [void],
    "nonpayable"
  >;

  closePerpetualPosition: TypedContractMethod<
    [positionId: BigNumberish],
    [void],
    "nonpayable"
  >;

  completeEscrow: TypedContractMethod<
    [escrowId: BigNumberish],
    [void],
    "nonpayable"
  >;

  createEscrow: TypedContractMethod<
    [
      buyer: AddressLike,
      token: AddressLike,
      amount: BigNumberish,
      deadline: BigNumberish
    ],
    [void],
    "nonpayable"
  >;

  createLottery: TypedContractMethod<
    [ticketPrice: BigNumberish, duration: BigNumberish],
    [void],
    "nonpayable"
  >;

  createPredictionMarket: TypedContractMethod<
    [question: string, duration: BigNumberish],
    [void],
    "nonpayable"
  >;

  depositMargin: TypedContractMethod<
    [amount: BigNumberish, token: AddressLike],
    [void],
    "nonpayable"
  >;

  escrowCounter: TypedContractMethod<[], [bigint], "view">;

  escrows: TypedContractMethod<
    [arg0: BigNumberish],
    [
      [string, string, string, bigint, bigint, boolean, boolean] & {
        seller: string;
        buyer: string;
        token: string;
        amount: bigint;
        deadline: bigint;
        completed: boolean;
        refunded: boolean;
      }
    ],
    "view"
  >;

  exerciseOption: TypedContractMethod<
    [optionId: BigNumberish, token: AddressLike],
    [void],
    "nonpayable"
  >;

  flashLoan: TypedContractMethod<
    [token: AddressLike, amount: BigNumberish],
    [void],
    "nonpayable"
  >;

  limitOrderCount: TypedContractMethod<[arg0: AddressLike], [bigint], "view">;

  limitOrders: TypedContractMethod<
    [arg0: AddressLike, arg1: BigNumberish],
    [
      [string, string, bigint, bigint, bigint, boolean] & {
        tokenIn: string;
        tokenOut: string;
        amountIn: bigint;
        targetPrice: bigint;
        deadline: bigint;
        executed: boolean;
      }
    ],
    "view"
  >;

  listNFT: TypedContractMethod<
    [tokenId: BigNumberish, price: BigNumberish],
    [void],
    "nonpayable"
  >;

  lotteries: TypedContractMethod<
    [arg0: BigNumberish],
    [
      [bigint, bigint, bigint, string, boolean] & {
        ticketPrice: bigint;
        deadline: bigint;
        prizePool: bigint;
        winner: string;
        drawn: boolean;
      }
    ],
    "view"
  >;

  lotteryCounter: TypedContractMethod<[], [bigint], "view">;

  marginBalance: TypedContractMethod<[arg0: AddressLike], [bigint], "view">;

  mintNFT: TypedContractMethod<[metadata: string], [void], "nonpayable">;

  nftContract: TypedContractMethod<[], [string], "view">;

  openPerpetualPosition: TypedContractMethod<
    [isLong: boolean, size: BigNumberish, leverage: BigNumberish],
    [void],
    "nonpayable"
  >;

  optionCount: TypedContractMethod<[arg0: AddressLike], [bigint], "view">;

  options: TypedContractMethod<
    [arg0: AddressLike, arg1: BigNumberish],
    [
      [bigint, bigint, bigint, boolean, boolean] & {
        strike: bigint;
        premium: bigint;
        expiry: bigint;
        isCall: boolean;
        exercised: boolean;
      }
    ],
    "view"
  >;

  owner: TypedContractMethod<[], [string], "view">;

  perpetualCount: TypedContractMethod<[arg0: AddressLike], [bigint], "view">;

  perpetuals: TypedContractMethod<
    [arg0: AddressLike, arg1: BigNumberish],
    [
      [bigint, bigint, bigint, boolean, bigint] & {
        size: bigint;
        leverage: bigint;
        entryPrice: bigint;
        isLong: boolean;
        margin: bigint;
      }
    ],
    "view"
  >;

  placeLimitOrder: TypedContractMethod<
    [
      tokenIn: AddressLike,
      tokenOut: AddressLike,
      amountIn: BigNumberish,
      targetPrice: BigNumberish,
      deadline: BigNumberish
    ],
    [void],
    "nonpayable"
  >;

  placePrediction: TypedContractMethod<
    [
      marketId: BigNumberish,
      side: boolean,
      amount: BigNumberish,
      token: AddressLike
    ],
    [void],
    "nonpayable"
  >;

  predictionBets: TypedContractMethod<
    [arg0: BigNumberish, arg1: AddressLike],
    [bigint],
    "view"
  >;

  predictionCounter: TypedContractMethod<[], [bigint], "view">;

  predictionSide: TypedContractMethod<
    [arg0: BigNumberish, arg1: AddressLike],
    [boolean],
    "view"
  >;

  predictions: TypedContractMethod<
    [arg0: BigNumberish],
    [
      [string, bigint, bigint, bigint, boolean, boolean] & {
        question: string;
        deadline: bigint;
        yesPool: bigint;
        noPool: bigint;
        resolved: boolean;
        outcome: boolean;
      }
    ],
    "view"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "buyLotteryTicket"
  ): TypedContractMethod<
    [lotteryId: BigNumberish, token: AddressLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "buyOption"
  ): TypedContractMethod<
    [
      isCall: boolean,
      strike: BigNumberish,
      premium: BigNumberish,
      expiry: BigNumberish,
      token: AddressLike
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "closePerpetualPosition"
  ): TypedContractMethod<[positionId: BigNumberish], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "completeEscrow"
  ): TypedContractMethod<[escrowId: BigNumberish], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "createEscrow"
  ): TypedContractMethod<
    [
      buyer: AddressLike,
      token: AddressLike,
      amount: BigNumberish,
      deadline: BigNumberish
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "createLottery"
  ): TypedContractMethod<
    [ticketPrice: BigNumberish, duration: BigNumberish],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "createPredictionMarket"
  ): TypedContractMethod<
    [question: string, duration: BigNumberish],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "depositMargin"
  ): TypedContractMethod<
    [amount: BigNumberish, token: AddressLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "escrowCounter"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "escrows"
  ): TypedContractMethod<
    [arg0: BigNumberish],
    [
      [string, string, string, bigint, bigint, boolean, boolean] & {
        seller: string;
        buyer: string;
        token: string;
        amount: bigint;
        deadline: bigint;
        completed: boolean;
        refunded: boolean;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "exerciseOption"
  ): TypedContractMethod<
    [optionId: BigNumberish, token: AddressLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "flashLoan"
  ): TypedContractMethod<
    [token: AddressLike, amount: BigNumberish],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "limitOrderCount"
  ): TypedContractMethod<[arg0: AddressLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "limitOrders"
  ): TypedContractMethod<
    [arg0: AddressLike, arg1: BigNumberish],
    [
      [string, string, bigint, bigint, bigint, boolean] & {
        tokenIn: string;
        tokenOut: string;
        amountIn: bigint;
        targetPrice: bigint;
        deadline: bigint;
        executed: boolean;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "listNFT"
  ): TypedContractMethod<
    [tokenId: BigNumberish, price: BigNumberish],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "lotteries"
  ): TypedContractMethod<
    [arg0: BigNumberish],
    [
      [bigint, bigint, bigint, string, boolean] & {
        ticketPrice: bigint;
        deadline: bigint;
        prizePool: bigint;
        winner: string;
        drawn: boolean;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "lotteryCounter"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "marginBalance"
  ): TypedContractMethod<[arg0: AddressLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "mintNFT"
  ): TypedContractMethod<[metadata: string], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "nftContract"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "openPerpetualPosition"
  ): TypedContractMethod<
    [isLong: boolean, size: BigNumberish, leverage: BigNumberish],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "optionCount"
  ): TypedContractMethod<[arg0: AddressLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "options"
  ): TypedContractMethod<
    [arg0: AddressLike, arg1: BigNumberish],
    [
      [bigint, bigint, bigint, boolean, boolean] & {
        strike: bigint;
        premium: bigint;
        expiry: bigint;
        isCall: boolean;
        exercised: boolean;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "owner"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "perpetualCount"
  ): TypedContractMethod<[arg0: AddressLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "perpetuals"
  ): TypedContractMethod<
    [arg0: AddressLike, arg1: BigNumberish],
    [
      [bigint, bigint, bigint, boolean, bigint] & {
        size: bigint;
        leverage: bigint;
        entryPrice: bigint;
        isLong: boolean;
        margin: bigint;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "placeLimitOrder"
  ): TypedContractMethod<
    [
      tokenIn: AddressLike,
      tokenOut: AddressLike,
      amountIn: BigNumberish,
      targetPrice: BigNumberish,
      deadline: BigNumberish
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "placePrediction"
  ): TypedContractMethod<
    [
      marketId: BigNumberish,
      side: boolean,
      amount: BigNumberish,
      token: AddressLike
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "predictionBets"
  ): TypedContractMethod<
    [arg0: BigNumberish, arg1: AddressLike],
    [bigint],
    "view"
  >;
  getFunction(
    nameOrSignature: "predictionCounter"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "predictionSide"
  ): TypedContractMethod<
    [arg0: BigNumberish, arg1: AddressLike],
    [boolean],
    "view"
  >;
  getFunction(
    nameOrSignature: "predictions"
  ): TypedContractMethod<
    [arg0: BigNumberish],
    [
      [string, bigint, bigint, bigint, boolean, boolean] & {
        question: string;
        deadline: bigint;
        yesPool: bigint;
        noPool: bigint;
        resolved: boolean;
        outcome: boolean;
      }
    ],
    "view"
  >;

  getEvent(
    key: "EscrowCreated"
  ): TypedContractEvent<
    EscrowCreatedEvent.InputTuple,
    EscrowCreatedEvent.OutputTuple,
    EscrowCreatedEvent.OutputObject
  >;
  getEvent(
    key: "FlashLoanExecuted"
  ): TypedContractEvent<
    FlashLoanExecutedEvent.InputTuple,
    FlashLoanExecutedEvent.OutputTuple,
    FlashLoanExecutedEvent.OutputObject
  >;
  getEvent(
    key: "LimitOrderPlaced"
  ): TypedContractEvent<
    LimitOrderPlacedEvent.InputTuple,
    LimitOrderPlacedEvent.OutputTuple,
    LimitOrderPlacedEvent.OutputObject
  >;
  getEvent(
    key: "LotteryCreated"
  ): TypedContractEvent<
    LotteryCreatedEvent.InputTuple,
    LotteryCreatedEvent.OutputTuple,
    LotteryCreatedEvent.OutputObject
  >;
  getEvent(
    key: "LotteryTicketBought"
  ): TypedContractEvent<
    LotteryTicketBoughtEvent.InputTuple,
    LotteryTicketBoughtEvent.OutputTuple,
    LotteryTicketBoughtEvent.OutputObject
  >;
  getEvent(
    key: "MarginDeposited"
  ): TypedContractEvent<
    MarginDepositedEvent.InputTuple,
    MarginDepositedEvent.OutputTuple,
    MarginDepositedEvent.OutputObject
  >;
  getEvent(
    key: "OptionBought"
  ): TypedContractEvent<
    OptionBoughtEvent.InputTuple,
    OptionBoughtEvent.OutputTuple,
    OptionBoughtEvent.OutputObject
  >;
  getEvent(
    key: "PerpetualOpened"
  ): TypedContractEvent<
    PerpetualOpenedEvent.InputTuple,
    PerpetualOpenedEvent.OutputTuple,
    PerpetualOpenedEvent.OutputObject
  >;
  getEvent(
    key: "PredictionMarketCreated"
  ): TypedContractEvent<
    PredictionMarketCreatedEvent.InputTuple,
    PredictionMarketCreatedEvent.OutputTuple,
    PredictionMarketCreatedEvent.OutputObject
  >;
  getEvent(
    key: "PredictionPlaced"
  ): TypedContractEvent<
    PredictionPlacedEvent.InputTuple,
    PredictionPlacedEvent.OutputTuple,
    PredictionPlacedEvent.OutputObject
  >;

  filters: {
    "EscrowCreated(uint256,address,address)": TypedContractEvent<
      EscrowCreatedEvent.InputTuple,
      EscrowCreatedEvent.OutputTuple,
      EscrowCreatedEvent.OutputObject
    >;
    EscrowCreated: TypedContractEvent<
      EscrowCreatedEvent.InputTuple,
      EscrowCreatedEvent.OutputTuple,
      EscrowCreatedEvent.OutputObject
    >;

    "FlashLoanExecuted(address,address,uint256)": TypedContractEvent<
      FlashLoanExecutedEvent.InputTuple,
      FlashLoanExecutedEvent.OutputTuple,
      FlashLoanExecutedEvent.OutputObject
    >;
    FlashLoanExecuted: TypedContractEvent<
      FlashLoanExecutedEvent.InputTuple,
      FlashLoanExecutedEvent.OutputTuple,
      FlashLoanExecutedEvent.OutputObject
    >;

    "LimitOrderPlaced(address,uint256)": TypedContractEvent<
      LimitOrderPlacedEvent.InputTuple,
      LimitOrderPlacedEvent.OutputTuple,
      LimitOrderPlacedEvent.OutputObject
    >;
    LimitOrderPlaced: TypedContractEvent<
      LimitOrderPlacedEvent.InputTuple,
      LimitOrderPlacedEvent.OutputTuple,
      LimitOrderPlacedEvent.OutputObject
    >;

    "LotteryCreated(uint256,uint256)": TypedContractEvent<
      LotteryCreatedEvent.InputTuple,
      LotteryCreatedEvent.OutputTuple,
      LotteryCreatedEvent.OutputObject
    >;
    LotteryCreated: TypedContractEvent<
      LotteryCreatedEvent.InputTuple,
      LotteryCreatedEvent.OutputTuple,
      LotteryCreatedEvent.OutputObject
    >;

    "LotteryTicketBought(uint256,address)": TypedContractEvent<
      LotteryTicketBoughtEvent.InputTuple,
      LotteryTicketBoughtEvent.OutputTuple,
      LotteryTicketBoughtEvent.OutputObject
    >;
    LotteryTicketBought: TypedContractEvent<
      LotteryTicketBoughtEvent.InputTuple,
      LotteryTicketBoughtEvent.OutputTuple,
      LotteryTicketBoughtEvent.OutputObject
    >;

    "MarginDeposited(address,uint256)": TypedContractEvent<
      MarginDepositedEvent.InputTuple,
      MarginDepositedEvent.OutputTuple,
      MarginDepositedEvent.OutputObject
    >;
    MarginDeposited: TypedContractEvent<
      MarginDepositedEvent.InputTuple,
      MarginDepositedEvent.OutputTuple,
      MarginDepositedEvent.OutputObject
    >;

    "OptionBought(address,uint256,bool,uint256)": TypedContractEvent<
      OptionBoughtEvent.InputTuple,
      OptionBoughtEvent.OutputTuple,
      OptionBoughtEvent.OutputObject
    >;
    OptionBought: TypedContractEvent<
      OptionBoughtEvent.InputTuple,
      OptionBoughtEvent.OutputTuple,
      OptionBoughtEvent.OutputObject
    >;

    "PerpetualOpened(address,uint256,bool,uint256)": TypedContractEvent<
      PerpetualOpenedEvent.InputTuple,
      PerpetualOpenedEvent.OutputTuple,
      PerpetualOpenedEvent.OutputObject
    >;
    PerpetualOpened: TypedContractEvent<
      PerpetualOpenedEvent.InputTuple,
      PerpetualOpenedEvent.OutputTuple,
      PerpetualOpenedEvent.OutputObject
    >;

    "PredictionMarketCreated(uint256,string)": TypedContractEvent<
      PredictionMarketCreatedEvent.InputTuple,
      PredictionMarketCreatedEvent.OutputTuple,
      PredictionMarketCreatedEvent.OutputObject
    >;
    PredictionMarketCreated: TypedContractEvent<
      PredictionMarketCreatedEvent.InputTuple,
      PredictionMarketCreatedEvent.OutputTuple,
      PredictionMarketCreatedEvent.OutputObject
    >;

    "PredictionPlaced(uint256,address,bool,uint256)": TypedContractEvent<
      PredictionPlacedEvent.InputTuple,
      PredictionPlacedEvent.OutputTuple,
      PredictionPlacedEvent.OutputObject
    >;
    PredictionPlaced: TypedContractEvent<
      PredictionPlacedEvent.InputTuple,
      PredictionPlacedEvent.OutputTuple,
      PredictionPlacedEvent.OutputObject
    >;
  };
}
